/* @file

	Implementation of device registration & callback handling.
	SPDX-License-Identifier: WTFPL

*/

#include "driver.h"
#include "device.tmh"
#include "Trace.h"
#include "MonitorThread.h"
#include "DebugOutput.h"
NTSTATUS UsbPerformancePanelCreateDevice(_Inout_ PWDFDEVICE_INIT DeviceInit)
/*++

Routine Description:

	Worker routine called to create a device and its software resources.

Arguments:

	DeviceInit - Pointer to an opaque init structure. Memory for this
					structure will be freed by the framework when the WdfDeviceCreate
					succeeds. So don't access the structure after that point.

Return Value:

	NTSTATUS

--*/
{
	WDF_PNPPOWER_EVENT_CALLBACKS pnpPowerCallbacks;
	WDF_OBJECT_ATTRIBUTES   deviceAttributes;
	PDEVICE_CONTEXT deviceContext;
	WDFDEVICE device;
	NTSTATUS status;
	WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);
	pnpPowerCallbacks.EvtDevicePrepareHardware = UsbPerformancePanelEvtDevicePrepareHardware;
	WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);

	WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);

	status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);

	if (NT_SUCCESS(status)) {
		//
		// Get a pointer to the device context structure that we just associated
		// with the device object. We define this structure in the device.h
		// header file. DeviceGetContext is an inline function generated by
		// using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
		// This function will do the type checking and return the device context.
		// If you pass a wrong object handle it will return NULL and assert if
		// run under framework verifier mode.
		//
		deviceContext = GetDeviceContext(device);

		//
		// Initialize the context.
		//

		//
		// Create a device interface so that applications can find and talk
		// to us.
		//
		status = WdfDeviceCreateDeviceInterface(device,&GUID_DEVINTERFACE_UsbPerformancePanel,NULL);
	}

	return status;
}

NTSTATUS
UsbPerformancePanelEvtDevicePrepareHardware(
	_In_ WDFDEVICE Device,
	_In_ WDFCMRESLIST ResourceList,
	_In_ WDFCMRESLIST ResourceListTranslated
)
/*++

Routine Description:

	In this callback, the driver does whatever is necessary to make the
	hardware ready to use.  In the case of a USB device, this involves
	reading and selecting descriptors.

Arguments:

	Device - handle to a device

Return Value:

	NT status value

--*/
{
	NTSTATUS status;
	PDEVICE_CONTEXT pDeviceContext;
	WDF_USB_DEVICE_SELECT_CONFIG_PARAMS configParams;

	UNREFERENCED_PARAMETER(ResourceList);
	UNREFERENCED_PARAMETER(ResourceListTranslated);

	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Entry");

	status = STATUS_SUCCESS;
	pDeviceContext = GetDeviceContext(Device);

	//
	// Create a USB device handle so that we can communicate with the
	// underlying USB stack. The WDFUSBDEVICE handle is used to query,
	// configure, and manage all aspects of the USB device.
	// These aspects include device properties, bus properties,
	// and I/O creation and synchronization. We only create the device the first time
	// PrepareHardware is called. If the device is restarted by pnp manager
	// for resource rebalance, we will use the same device handle but then select
	// the interfaces again because the USB stack could reconfigure the device on
	// restart.
	//
	if (pDeviceContext->UsbDevice == NULL) {

#if UMDF_VERSION_MINOR >= 25
		WDF_USB_DEVICE_CREATE_CONFIG createParams;

		WDF_USB_DEVICE_CREATE_CONFIG_INIT(&createParams,
			USBD_CLIENT_CONTRACT_VERSION_602);

		status = WdfUsbTargetDeviceCreateWithParameters(Device,
			&createParams,
			WDF_NO_OBJECT_ATTRIBUTES,
			&pDeviceContext->UsbDevice
		);
#else
		status = WdfUsbTargetDeviceCreate(Device,
			WDF_NO_OBJECT_ATTRIBUTES,
			&pDeviceContext->UsbDevice
		);
#endif

		if (!NT_SUCCESS(status)) {
			TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE,
				"WdfUsbTargetDeviceCreateWithParameters failed 0x%x", status);
			return status;
		}
	}

	//
	// Select the first configuration of the device, using the first alternate
	// setting of each interface
	//
	WDF_USB_DEVICE_SELECT_CONFIG_PARAMS_INIT_MULTIPLE_INTERFACES(&configParams,
		0,
		NULL
	);
	status = WdfUsbTargetDeviceSelectConfig(pDeviceContext->UsbDevice,
		WDF_NO_OBJECT_ATTRIBUTES,
		&configParams
	);

	if (!NT_SUCCESS(status)) {
		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE,
			"WdfUsbTargetDeviceSelectConfig failed 0x%x", status);
		return status;
	}
	PanelDataCapability cap=0;
	status = GetDataCapability(pDeviceContext, &cap);
	if (!NT_SUCCESS(status)) {
		pDeviceContext->DevicePanelDataCapability = 0x03;//fallback val.
	}
	else {
		pDeviceContext->DevicePanelDataCapability = cap;
	}
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Exit");
	pDeviceContext->DelayTime = 1000;
	// Start the Monitor thread!
	WDFTIMER ret = StartMonitorThread(Device);
	if (ret == NULL) {
		PrintDebug("Start thread failed.\n");
		StopDebug();
		ExitProcess(3);
	}
	pDeviceContext->Timer = ret;
	PrintDebug("Thread started.\n");
	return status;
}
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS SendUsage(PDEVICE_CONTEXT DevContext, PanelDataCapability cap, UCHAR data)
{
	/*++

Routine Description:

	Worker routine send a specific usage of one specific hardware.

Arguments:

	DevContext:Device context.
	cap:The PanelDataCapability of your selection.
	data:raw data.

Return Value:

	NTSTATUS

--*/
	PrintDebug("Sending 0x%x->0x%x......",cap,data);
	NTSTATUS status = 0;
	WDF_USB_CONTROL_SETUP_PACKET    controlSetupPacket;
	WDF_REQUEST_SEND_OPTIONS        sendOptions;
	PAGED_CODE();
	TraceEvents(TRACE_LEVEL_VERBOSE, TRACE_DEVICE, "-->TransportUsage\n");
	WDF_REQUEST_SEND_OPTIONS_INIT(&sendOptions,WDF_REQUEST_SEND_OPTION_TIMEOUT);
	WDF_REQUEST_SEND_OPTIONS_SET_TIMEOUT(&sendOptions,DEFAULT_CONTROL_TRANSFER_TIMEOUT);
	WDF_USB_CONTROL_SETUP_PACKET_INIT_VENDOR(&controlSetupPacket,BmRequestHostToDevice,BmRequestToDevice,COMMAND_SET_USAGE,((UCHAR)cap<<8)|data, CONTROL_CHANNEL);
	status = WdfUsbTargetDeviceSendControlTransferSynchronously(DevContext->UsbDevice,NULL,&sendOptions,&controlSetupPacket,NULL,NULL);
	if (!NT_SUCCESS(status)) {
		STATUS_IO_TIMEOUT;
		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE,
			"Failed to set Usage - 0x%x \n", status);
		PrintDebug("Failed:0x%x\n",status);
	}
	else {
		TraceEvents(TRACE_LEVEL_VERBOSE, TRACE_DEVICE,
			"SetSevenSegmentState: 0x%x usage is 0x%x\n",cap,data);
		PrintDebug("Success\n");
	}
	TraceEvents(TRACE_LEVEL_VERBOSE, TRACE_DEVICE, "<--TransportUsage\n");
	return status;
}
NTSTATUS GetDataCapability(PDEVICE_CONTEXT DevContext, PanelDataCapability* ReceiveBuffer)
{
	WDF_USB_CONTROL_SETUP_PACKET    controlSetupPacket;
	WDF_REQUEST_SEND_OPTIONS        sendOptions;
	ULONG byteTransferred;
	WDF_MEMORY_DESCRIPTOR memDesc;
	WDF_MEMORY_DESCRIPTOR_INIT_BUFFER(&memDesc, ReceiveBuffer, sizeof(UCHAR));
	WDF_REQUEST_SEND_OPTIONS_INIT(&sendOptions, WDF_REQUEST_SEND_OPTION_TIMEOUT);
	WDF_REQUEST_SEND_OPTIONS_SET_TIMEOUT(&sendOptions, DEFAULT_CONTROL_TRANSFER_TIMEOUT);
	WDF_USB_CONTROL_SETUP_PACKET_INIT_VENDOR(&controlSetupPacket, BmRequestDeviceToHost, BmRequestToDevice,COMMAND_QUERY_CAP,0, CONTROL_CHANNEL);
	NTSTATUS status = WdfUsbTargetDeviceSendControlTransferSynchronously(DevContext->UsbDevice, NULL, &sendOptions, &controlSetupPacket, &memDesc, &byteTransferred);

	if (!NT_SUCCESS(status)) {
		STATUS_IO_TIMEOUT;
		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DEVICE,
			"Failed to set Usage - 0x%x \n", status);
		PrintDebug("Failed:0x%x\n", status);
	}
	else {
		TraceEvents(TRACE_LEVEL_VERBOSE, TRACE_DEVICE,
			"GetCompat: 0x%x bytes: 0x%x\n", byteTransferred, *ReceiveBuffer);
		PrintDebug("GetCompat: 0x%x bytes: 0x%x\n", byteTransferred, *ReceiveBuffer);
	}
	return status;
}